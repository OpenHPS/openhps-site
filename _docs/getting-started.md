---
layout: 'docs'
title: 'Getting Started'
menuOrder: 1
redirect_from:
  - /getting-started
---

# Getting Started
This documentation provides a brief overview of OpenHPS, its creators and how to get started using the components in your projects.

## About
OpenHPS is a open source hybrid positioning system that allows developers to merge multiple positioning techniques and algorithms together in a graph structure. It is being developed by PhD Student [Maxim Van de Wynckel](https://wise.vub.ac.be/member/maxim-van-de-wynckel) as part of his research towards *Hybrid Positioning and Implicit Human-Computer Interaction* under the supervision of [Prof. Dr. Beat Signer](https://wise.vub.ac.be/member/beat-signer).

The core **Model** of OpenHPS is a graph-based data processing framework aimed for sampling an output position from input sensory data.
![Architectural Overview](/images/docs/architecture1.svg)
A model holds a graph where each node contributes to the processing of information. This information is encapsulated in *frames* that hold information of multiple *objects*. Three types of nodes are identified:
- **Source Nodes**: Generate new data frames for the next connected node(s).
- **Processing Nodes**: Process the information generated by source node(s).
- **Sink Nodes**: Save the information generated by source nodes and processed by others.

Our core API provide basic nodes that can help process the most common sensory data (e.g. filter nodes, common graph shapes, merging, basic positioning algorithms). However, the extensible API also allows developers to create their own nodes.

Data frames hold information about the source that generated the information and any object that is included in the sensory data. This can range from objects that are identified by their MAC address to more abstract objects such as the map of a room. Objects inside this frame have an absolute position, multiple relative positions and a potential parent object (e.g. the sensor of a phone has the phone as the parent object).

Each node has access to services. These services can hold information about previous positions of object or calibration data.
![Architectural Overview Offline and Online Stage](/images/docs/architecture2.svg)
External data services can be added to transfer data generated during the set up of the positioning system to the online stage.

More in-depth information can be found in the [core API description](/docs/core) ...

## Components
OpenHPS is split up into multiple components that each offer a certain set of functionalities. The core API (@openhps/core) offers the graph-based model and commonly used nodes for sampling absolute and relative positions. Various additions such as *@openhps/imu*, *@openhps/dsp* or *@openhps/rf* can be added to extend the framework with motion data, digital signal processing algorithms and RF-based positioning respectively.

## Installation
If you have [npm installed](https://www.npmjs.com/get-npm), start using @openhps/core with the following command.
```bash
npm install @openhps/core --save
```

### Webpack
Most of the OpenHPS component are optimized for browsers. However, please refer to each components README page for more information on how to bundle the components.

## Concepts
This section of the documentation describes the main concepts of the core components.

### ```Model```
An OpenHPS model contains a graph that connects [nodes](#node) with edges. The goal of the model is to process sensor data.

The graph construction of a model is immutable and has to be constructed using a [```ModelBuilder```](/docs/core/classes/_modelbuilder_.modelbuilder.html).
Once a model is created, it can be used as a node inside another graph/model or directly used to push and pull information from.

### ```Node```
Nodes are part of the graph created through the [model](#model). [Data frames](#dataframe) can be **pushed** to a node where it can be manipulated and pushed to the outgoing edges of that node. When **pulling** a node it requests data from that node or other nodes before that, but each node will have to perform a push to actually
send this data.

#### ```SourceNode```
A source node is a node that creates a [data frame](#dataframe). This can be directly from a sensor or through a remote interface. By default the node is pull-based

#### ```SinkNode```
Sink nodes do not push data to the next node in the graph. In addition, all [data objects](#dataobject) received by a sink node are stored to
the corresponding [data service](#dataservice).

#### ```ProcessingNode```
This type of node processes a [data frame](#dataframe). Other than normal nodes this type of node adds an abstraction that will update the *processed* data frame
in the [data frame service](#dataservice).

### ```Position```
A Position is an abstract interface that represents a [relative](#relativeposition) or [absolute](#absoluteposition) position. Every position contains a timestamp, accuracy, velocity and orientation.

#### ```RelativePosition```
A relative position is part of a [```DataObject```](#dataobject) that is relative to the absolute position of a single other [```DataObject```](#dataobject).
By default, the framework supports relative position based on [distance](/docs/core/classes/_data_position_relativedistanceposition_.relativedistanceposition.html) or 
[angle](/docs/core/classes/_data_position_relativeangleposition_.relativedistanceposition.html).

#### ```AbsolutePosition```
An absolute position is the fixed position of a [```DataObject```](#dataobject). This position can be provided during the set up or calibration of the [```Model```](#model). It can also be determined using various positioning techniques and algorithms.

By default, OpenHPS provides absolute position in the form of [geographical positions](/docs/core/classes/_data_position_geographicalposition_.geographicalposition.html) or [cartesian coordinates](/docs/core/classes/_data_position_absolute3dposition_.absolute3dposition.html).

#### ```Orientation```
Orientation of data objects is represented using [```Quaternions```](/docs/core/modules/_utils_math_quaternion_.html).

#### ```Velocity```
The velocity of a position contains both the linear and angular velocity at the position.

### ```DataFrame```
DataFrames are timestamped data generated by a source. They should contain the data that the source created or captured such as sensory data or processed sensory data.

### ```DataObject```
Data object includes everything that is relevant to the positioning system. These can be the sources
that generate a [```DataFrame```](#dataframe) or referenced objects in a [```RelativePosition```](#relativeposition).

### ```ReferenceSpace```


### ```Service```
Each [model](#model) can have multiple services that can be accessed by any [node](#node) in the graph.

#### ```DataService```
By default each [model](#model) has a data services for storing temporary [data frames](#dataframe) that are being processed in the model and
data objects that are received by a [```SinkNode```](#sinknode).

The OpenHPS core component only offers memory-based services. If you are looking for a more optimised or persistent storage, take a look at [@openhps/database](/docs/database/) that uses MongoDB.

### ```Unit```
In order to account for different precisions and units with various positioning methods or components, each measurement is accompanied with a [unit](/docs/core/classes/_utils_unit_unit_.unit.html).

- [```LengthUnit```](/docs/core/classes/_utils_unit_lengthunit_.lengthunit.html): Provides units for length (by default [metric](/docs/core/classes/_utils_unit_metriclengthunit_.metriclengthunit.html))
- [```AngleUnit```](/docs/core/classes/_utils_unit_angleunit_.angleunit.html): Provides the unit for angles (radians and degrees)
- [```TimeUnit```](/docs/core/classes/_utils_unit_timeunit_.timeunit.html): Provides the unit for time.
- ```AngularVelocityUnit```:
- ```LinearVelocityUnit```:

## Usage

### Model Creation
Models can be created using the [```ModelBuilder```](/docs/core/classes/_modelbuilder_.modelbuilder.html). Once you have added all services and constructed the graph, you can build the model using the ```build()``` function. A promise will be returned with the created model.
```typescript
import { ModelBuilder } from '@openhps/core';

ModelBuilder.create()
    .build().then(model => {
        // ...
    });
```
The graph shape of a model is immutable and can not be altered after building.

#### Shape Builder
Shapes can be created by starting with the ```from()``` function. This function takes an optional
parameter of one or multiple [source nodes](#sourcenode).

In order to end a shape, the ```to()``` function needs to be called with one or more optional [sink nodes](#sinknode).
```typescript
import { ModelBuilder } from '@openhps/core';

ModelBuilder.create()
    .from()
    .to()
    .build().then(model => {
        // ...
    });
```

Alternatively for readability with multiple shapes, the shapes can individually be created using the ```addShape()``` function as shown below.
```typescript
import { ModelBuilder, GraphBuilder } from '@openhps/core';

ModelBuilder.create()
    .addShape(
      GraphBuilder.create()
        .from()
        .to())
    .build().then(model => {
        // ...
    });
```

##### Building Source Processors
It is possible to have multiple processing nodes between the source and sink. These processing nodes can manipulate the data frame
when it traverses from node to node.
```typescript
import { ModelBuilder } from '@openhps/core';

ModelBuilder.create()
    .from(...)
    .via(new ComputingNode())
    .via(new AnotherComputingNode())
    .to(...)
    .build().then(model => {
        // ...
    });
```

##### Helper Functions
Helper functions can replace the ```via()``` function. Commonly used nodes such as frame filters, merging of data frames from
multiple sources, ... can be replaced with simple functions as ```filter()``` or ```merge()``` respectively.
```typescript
import { ModelBuilder } from '@openhps/core';
import { CSVSourceNode, CSVSinkNode } from '@openhps/csv';

ModelBuilder.create()
    .from(
        new CSVSourceNode('scanner1.csv', ...),
        new CSVSourceNode('scanner2.csv', ...),
        new CSVSourceNode('scanner3.csv', ...)
    )
    .filter((frame: DataFrame) => true)
    .merge((frame: DataFrame) => frame.source.uid)
    .via(new ComputingNode())
    .via(new AnotherComputingNode())
    .to(new CSVSinkNode('output.csv', ...))
    .build().then(model => {
        // ...
    });
```

#### Debug Logging
When building the model, you can provide a logger callback that has two arguments. An error level complying
with normal log levels and a log object that represents an object.
```typescript
import { ModelBuilder } from '@openhps/core';

ModelBuilder.create()
    // Set the logger that will be used by all nodes and services
    .withLogger((level: string, log: any) => { 
        console.log(log); 
    })
    // ...
    .build().then(model => {
/       / ...
    });
```
*More information about this example can be found in the [API documentation](/docs/core/classes/_modelbuilder_.modelbuilder.html#withlogger)*

#### Adding Services
Adding services can be done using the ```addService()``` function in the model builder.
```typescript
import { ModelBuilder } from '@openhps/core';

ModelBuilder.create()
    .addService(...)
    // ...
    .build().then(model => {

    });
```

### Multi Threading
Multi threading in OpenHPS is achieved using web workers (browser) and forked processes in NodeJS. The following example
shows how a fingerprinting node can be multithreaded.

```typescript
import { ModelBuilder, WorkerNode } from '@openhps/core';

ModelBuilder.create()
    .from(...)
    .via(new WorkerNode((builder) => {
        const { KNNFingerprintingNode } = require('@openhps/fingerprinting');
        builder.via(new KNNFingerprintingNode({
            k: 5,
            weighted: true,
        }, object => object.uid === "phone"))
    }, { poolSize: 4 }))
    .to(...)
    .build().then(model => {
        // ...
    });
```
In this example we create a new worker node that takes a builder function. The ```builder``` parameter of this function
is the model builder, meaning you can create complex shapes inside the thread. Note that imports of nodes need to be defined
inside the builder function.

The options given to the worker node include the pool size and a reference to the current working directory so that the imports in the builder function are relative to current file.

Data services are added to the threaded model. Requests made to these services inside the thread will be forwarded to the main thread.

### Pushing a ```DataFrame```
[Data frames](#dataframe) should normally only be created by a [source node](#sourcenode). However, it is possible to
manually create a data frame and push it to a model.

```typescript
import { DataObject, DataFrame } from '@openhps/core';

/**
 * Create a new source object
 *  The object should be initialised using a unique identifier
 *  e.g. hardware or browser fingerprint
 **/
const source = new DataObject("source_id");
/**
 * Create a new data frame
 *  Provided is the source object responsible for creating the
 *  frame
 **/
const frame = new DataFrame(source);

/**
 * Push a data frame to a previously created model
 **/
model.push(frame).then(() => {
    // Pushed and processed
}).catch(ex => {
    // Error while pushing/processing
});

/**
 * Push a data frame to a previously created model, with options
 **/
model.push(frame, {
    // ...
}).then(() => {
    // Pushed and processed
}).catch(ex => {
    // Error while pushing/processing
});
```
*More information about this example can be found in the [API documentation](/docs/core/interfaces/_model_.model.html#push)*

### Creating a ```DataFrame```
Custom data frames can be created by extending the default ```DataFrame``` class. Important when handling
data frames (and objects) is to add serializable decorators.
```typescript
import { DataFrame, SerializableObject, SerializableArrayMember } from '@openhps/core';

@SerializableObject()
export class CustomDataFrame extends DataFrame {
    @SerialisableArrayMember(Number)
    public customFrameAttribute: number[];
}
```

### Creating a ```Node```
Default nodes require you to specify the input and output data frame type. In general, nodes have the ability
to process an input data frame and output a different (processed) data frame.
```typescript
import { DataFrame, Node } from '@openhps/core';

export class CustomNode<In extends DataFrame, Out extends DataFrame> extends Node<In, Out> {
    // ...
}
```
Abstract implementations such as a ```SourceNode``` and ```SinkNode``` only take one input or output
data frame type as they do not process or change the frame.

### Creating a ```SourceNode```
When creating a source node, you have to implement a promise based ```onPull``` method that expects a data
frame.

As mentioned in the [description of the node concept](#node), pulling normally does not require you to return
a data frame. The source node implementation provides an abstraction on top of this. If your source node can generate
data frames, you can resolve to a data frame. The data frame will then be pushed to outgoing nodes. 
If not, you can simply resolve nothing or a null object.

On top of this abstraction, a source node adds an intermediate output node that merges data objects from the [data service](#dataservice).
This way, the data frame pushed by the source will always be up-to-date and merged with existing processed information.

```typescript
import { DataFrame, SourceNode } from '@openhps/core';

export class CustomSource<Out extends DataFrame> extends SourceNode<Out> {
    // ...

    constructor() {
        // Source nodes expect a source object to be provided
        super(new DataObject("mobile_input")));
    }

    public onPull(options?: GraphPullOptions): Promise<Out> {
        return new Promise<Out>((resolve, reject) => {
            // ... pull request
            // ... get data from somewhere

            const dataFrame = new DataFrame(this.getSource());
            resolve(dataFrame);
        });
    }
}
```

### Creating a ```SinkNode```
When creating a sink node, you have to implement an ```onPush``` method that provides you with the pushed data frame.
Sink nodes are the final nodes in the model and have no outgoing edges. Once the onPush is resolved, the data frame
is removed from the [data frame service](#dataservice) and data objects in that frame are stored in the data object service.
```typescript
import { DataFrame, SinkNode } from '@openhps/core';

export class CustomSink<In extends DataFrame> extends SinkNode<In> {
    // ...

    public onPush(data: In, options?: GraphOptions): Promise<void> {
        return new Promise<void>((resolve, reject) => {

        });
    }
}
```

### Creating a ```ProcessingNode```
Processing nodes hide the push and pull functionalities from a regular node. When a push is received, this
data frame is provided to the ```process``` method that has to be implemented. When a pull is received, this pull is
forwarded to all incoming nodes.
```typescript
import { DataFrame, DataObject, ProcessingNode } from '@openhps/core';

export class CustomProcessingNode<In extends DataFrame, Out extends DataFrame> extends ProcessingNode<In, Out> {
    // ...

    public process(data: In, options?: GraphOptions): Promise<Out> {
        return new Promise<Out>((resolve, reject) => {
            // ... process/manipulate the data frame
            data.addObject(new DataObject("custom_process_object"));
            resolve(data);
        });
    }

}
```

### Creating an ```ObjectProcessingNode```
Extended on a [processing node](#processingnode) is an object processing node that processes individual objects in each frame.
```typescript
import { DataFrame, DataObject, ObjectProcessingNode } from '@openhps/core';

export class CustomObjectProcessingNode<InOut extends DataFrame> extends ObjectProcessingNode<InOut> {
    // ...

    public processObject(object: DataObject, frame?: DataFrame): Promise<DataObject> {
        return new Promise<DataObject>((resolve, reject) => {
            // Manipulate the object
            object.displayName = "test";
            resolve(object);
        });
    }

}
```

### Finding a ```DataService```
```typescript
import { Model, Node, DataFrame } from '@openhps/core';

export class CustomNode extends Node<DataFrame> {
    /**
     * Data services can be found in any function inside a node
     * that is added to a model
     **/
    public functionInsideNode(): void {
        // Get the model that this node is added to
        const model: Model<any, any> = (this.graph as Model<any, any>);
        // Get a service by its type
        let service = model.findDataService(DataObject);
        let service = model.findDataServiceByName("DataObject");
    }
}
```